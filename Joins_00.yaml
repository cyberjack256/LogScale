name: Joins_00
timeSelector: {}
sharedTimeInterval:
  enabled: false
  isLive: false
  start: 1d
widgets:
  25298568-8f50-4624-9c2f-60fe778ca15b:
    x: 0
    y: 0
    height: 5
    queryString: |
      patient_id !=patient_id #type=appointments_csv| join({#type=patients_csv}, field=patient_id, key=patient_id, repo=02_patients, mode=left, include=[first_name,last_name,age,gender])
      |table([first_name, last_name, age, gender, appointment_id, doctor_id, reason])
    visualization: table-view
    end: now
    start: 1y
    width: 5
    title: Patients and Corresponding Appointments
    isLive: false
    type: query
  36a01570-49c7-4bed-a216-931a2a6bac89:
    x: 0
    y: 5
    height: 5
    queryString: |-
      #type=appointments_csv
      | join({#type=patients_csv age > 40}, field=patient_id, key=patient_id, repo=02_patients, include=[first_name,last_name,age,gender])
      |table([first_name, last_name, age, gender, appointment_id, doctor_id, reason])
    visualization: table-view
    end: now
    start: 1y
    width: 5
    title: Patients over 40
    isLive: false
    type: query
  note-1680986366237-0:
    x: 5
    y: 0
    height: 10
    text: |-
      ## Join Statements
      Join statements combine data from multiple repositories based on common fields. In LogScale, `join()` is used to join two or more repositories and return a combined result set.
      ### Understanding the `join()` Function
      `join()` statements can be useful when combining information from multiple repositories. This allows for more comprehensive data analysis and decision-making.
      ### Join Statements and Set Theory
      - Inner join: Returns only records that have matching values in both repositories. If there's a record in the first repository that doesn't have a corresponding record in the second repository, that record is not included in the result.
      - Outer join: Returns all records from both repositories, and fills in null values for non-matching records.
      ### Joining Datasets in LogScale
      - Define keys/fields used to match results using `field=name` or `field=[name,name,...]`.
      #### Example Inner Join
      An inner join returns only records with matching values in both repositories. For example, joining a repository of access logs with a repository of invalid SSH attempts to find IP addresses associated with both types of events.
      #### Example Left (Outer) Join
      - A left join returns all records from both repositories, and fills in null values for non-matching records. For example, joining a repository of access logs with a repository of usernames to find all events with an error status OR those that include an IP address with a username from the access logs.
      ### Important Notes Regarding Joins
      - Keys Fields: Define keys or fields used to match results using `field=` or `key=`.
      - Modes: `join()` has two modes: `inner` (default) and `left`.
      `inner` only lets records that match the join key(s) through. If you specify `mode=left`, records that donâ€™t match the join key(s) will also pass through.
      - Max: Use the `max=` parameter to specify how many rows/records are picked up in the subquery. If a subquery has multiple records with the same join key, up to the specified `max` rows are emitted.
      - Start and End: Use the `start=` and `end=` parameters to specify an alternative time interval for the query.
      - View (permission context): Use the `view=` parameter to direct the subquery to run in a different context in another repository or view (default: main query context).
      - Live: Use the `live=` parameter to control if the subquery runs as a live query.
      ### Join Syntax
      The `join()` function's signature looks like this:
      ```
      join({subquery}, field=arg1, key=arg2, repo=arg3, mode=inner|left, include[field1, field2])
      ```
      **Note:** The unnamed subquery argument, and the named field and key arguments, are required. The named repo, include, and mode parameters are optional.
      #### Joining Two Repositories
      To join two repositories, use the optional repo parameter to define the repository (arg3) you want the subquery to run against.
      #### Limitations of Live Joins
      Joins can simulate being live by repeatedly running at a time interval determined by the server. Results will appear when the query is re-run, not when data is ingested. LogScale notions of liveness and joins are not compatible, meaning that the results of live queries using the `join()` function may become incorrect over time.
      ### Best Practices for Join Queries
      - Ensure the right query is significantly smaller than the left query for better performance.
      - Be aware that using live queries with the `join()` function has limitations due to constantly changing data.
      **Example 1:** Inner join to find patient details for each appointment
      In this example, we will join the appointments repository with the patients repository to get the patient details for each appointment.
      ```
      #type=appointments_csv
      | join({#type=patients}, field=patient_id, key=patient_id, repo=patients, include=[first_name,last_name,age,gender])
      | table([first_name, last_name, age, gender, appointment_id, doctor_id, reason])
      ```
      This query will return a result set containing appointment details along with the corresponding patient details for each appointment, where the patient_id field in both repositories matches.
      **Example 2:** Left join to find all appointments with patient details when available
      In this example, we will use a left join to return all appointment records along with patient details when available.
      ```
      #type=appointments_csv
      | join({#type=patients_csv}, field=patient_id, key=patient_id, repo=02_patients, mode=left, include=[first_name,last_name,age,gender])
      | table([first_name, last_name, age, gender, appointment_id, doctor_id, reason])
      ```
      This query will return a result set containing all appointments. For appointments with a matching patient_id in the patients repository, the patient details will be included in the result set. For appointments without a matching patient_id, the patient details will be null.
      **Example 3:** Inner join to find appointments for patients over a certain age
      In this example, we will find
      appointments for patients over 40 years old.
      ```
      #type=appointments_csv
      | join({#type=patients_csv age > 40}, field=patient_id, key=patient_id, repo=02_patients, include=[first_name,last_name,age,gender])
      | table([first_name, last_name, age, gender, appointment_id, doctor_id, reason])
      ```
      This query will return a result set containing appointments where the corresponding patient is over 40 years old. This is achieved by applying a filter condition to the patients repository in the subquery.
      #### Self Join
      `selfJoin()` function is another type of join operation in LogScale that allows joining the data with itself based on some matching criteria.

      ```LOGSCALE
      # Example usage
      selfJoin(field='appointment_id', where=[{'#type=appointments_csv date=*2023-06-09*'}, {'#type=appointments_csv date=*2023-06-09*'}], collect=['appointment_id', 'date'])
      ```
      #### Usage Considerations

      `selfJoin()` does two passes over the data and can't run truly live.
      It has a default limit of 20,000 matching join keys, configurable with the `GroupMaxLimit` setting.
      False positives can occur due to the probabilistic approach, increasing with the number of matching join keys.
